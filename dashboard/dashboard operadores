{
  "cells": [
    {
      "cell_type": "code",
      "source": [
        "# --- PASO 0: REQUISITOS PREVIOS PARA GOOGLE COLAB ---\n",
        "# ¡IMPORTANTE!: Este bloque asegura que Google Chrome y las librerías necesarias estén instaladas.\n",
        "\n",
        "# Instalar Selenium, BeautifulSoup, Pandas y Webdriver Manager\n",
        "!pip install selenium beautifulsoup4 pandas webdriver-manager requests dash > /dev/null 2>&1\n",
        "\n",
        "# --- INSTALACIÓN DE GOOGLE CHROME EN COLAB ---\n",
        "# 1. Descargar la clave GPG de Google Chrome\n",
        "!wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-chrome-archive-keyring.gpg\n",
        "\n",
        "# 2. Añadir el repositorio de Google Chrome a las fuentes de apt\n",
        "!echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome-archive-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main\" | sudo tee /etc/apt/sources.list.d/google-chrome.list\n",
        "\n",
        "# 3. Actualizar los listados de paquetes apt para incluir el nuevo repositorio\n",
        "!sudo apt-get update\n",
        "\n",
        "# 4. Instalar Google Chrome estable\n",
        "!sudo apt-get install -y google-chrome-stable\n",
        "\n",
        "# Opcional: Verificar la versión de Chrome instalada\n",
        "!google-chrome --version\n",
        "\n",
        "print(\"\\n--- Instalación de Chrome y dependencias completada ---\")\n",
        "\n",
        "\n",
        "# --- PASO 2: IMPORTAR LIBRERÍAS ---\n",
        "from selenium import webdriver\n",
        "from selenium.webdriver.chrome.service import Service\n",
        "from selenium.webdriver.common.by import By\n",
        "from selenium.webdriver.support.ui import WebDriverWait\n",
        "from selenium.webdriver.support import expected_conditions as EC\n",
        "from bs4 import BeautifulSoup\n",
        "import time\n",
        "import pandas as pd\n",
        "import re\n",
        "\n",
        "from webdriver_manager.chrome import ChromeDriverManager\n",
        "import requests # Agregado para el scraping de Entel si usa requests\n",
        "\n",
        "import dash\n",
        "from dash import dcc\n",
        "from dash import html\n",
        "from dash.dependencies import Input, Output\n",
        "from dash import dash_table # Importar dash_table para la tabla de datos\n",
        "\n",
        "# --- TUS FUNCIONES REALES DE EXTRACCIÓN DE PLANES ---\n",
        "# ¡IMPORTANTE!: Estas funciones contienen el código de scraping para cada operador.\n",
        "# Asegúrate de que todas devuelvan una lista de diccionarios con un esquema consistente.\n",
        "\n",
        "def extraer_planes_movistar_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Movistar.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://www.movistar.com.pe/movil/postpago/planes-postpago\"\n",
        "    planes_data = []\n",
        "\n",
        "    # --- CONFIGURACIÓN DE SELENIUM PARA COLAB ---\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1920,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "    options.add_experimental_option('excludeSwitches', ['enable-logging'])\n",
        "\n",
        "    driver = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        # --- ESPERAR A QUE EL CONTENIDO DINÁMICO CARGUE ---\n",
        "        wait = WebDriverWait(driver, 30)\n",
        "        try:\n",
        "            wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'p-plan__slide__soles')))\n",
        "        except Exception as e:\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n",
        "            time.sleep(5)\n",
        "            try:\n",
        "                wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'p-plan__slide__soles')))\n",
        "            except Exception as e:\n",
        "                print(f\"ERROR (Movistar): 'p-plan__slide__soles' no se hizo visible incluso después de scroll. {e}\")\n",
        "                print(\"La estructura de la página o la forma en que carga el contenido ha cambiado significativamente o hay un bloqueo persistente.\")\n",
        "                return []\n",
        "\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='p-plan__slide__shadow')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR (Movistar): No se encontraron elementos con la clase 'p-plan__slide__shadow'.\")\n",
        "            print(\"Esto podría indicar que la clase ha cambiado nuevamente o el contenido no se cargó como se esperaba.\")\n",
        "            return []\n",
        "\n",
        "        for i, plan_element in enumerate(plan_elements):\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            precio_tag = plan_element.find('span', class_='p-plan__slide__soles')\n",
        "            if precio_tag:\n",
        "                precio = precio_tag.get_text(strip=True)\n",
        "\n",
        "            head_tag = plan_element.find('div', class_='p-plan__slide__head')\n",
        "            if head_tag:\n",
        "                name_tag = head_tag.find(['h3', 'h4', 'span', 'p'], class_=lambda x: x and ('p-plan__slide__name' in x or 'title' in x or 'plan-name' in x))\n",
        "                if name_tag:\n",
        "                    nombre_plan = name_tag.get_text(strip=True)\n",
        "                else:\n",
        "                    nombre_plan = ' '.join(head_tag.get_text(separator=' ', strip=True).split())\n",
        "\n",
        "                nombre_plan = re.sub(r'Plan Postpago\\s*', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'S/\\s*\\d+\\.\\d+', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'al mes', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'x \\d+ meses', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Precio regular:.*?(Ahorra \\d+%)?', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Bono \\d+ GB', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Exclusivo online', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'\\*', '', nombre_plan).strip()\n",
        "                nombre_plan = re.sub(r'\\s{2,}', ' ', nombre_plan).strip()\n",
        "\n",
        "                if not nombre_plan:\n",
        "                    nombre_plan = f\"Plan Postpago {precio}\" if precio != 'N/A' else 'Plan Postpago Desconocido'\n",
        "\n",
        "            gigas_cantidad_tag = plan_element.find('span', class_='p-plan__slide__cantidad')\n",
        "            if gigas_cantidad_tag:\n",
        "                extracted_gigas = gigas_cantidad_tag.get_text(strip=True).replace('\\n', ' ').strip()\n",
        "                if \"GB\" in extracted_gigas.upper() or re.match(r'^\\d+(\\.\\d+)?\\s*GB$', extracted_gigas, re.IGNORECASE):\n",
        "                    gigas = extracted_gigas\n",
        "                    detalles_gigas = \"En Alta Velocidad\"\n",
        "                elif \"Bono\" in extracted_gigas and \"GB\" in extracted_gigas:\n",
        "                    gigas = extracted_gigas\n",
        "                    detalles_gigas = \"Bono de Gigas\"\n",
        "\n",
        "            if gigas == 'N/A':\n",
        "                ilimitado_tag = plan_element.find(['span', 'div', 'h3', 'p'], class_=lambda x: x and ('p-plan__slide__gigas' in x or 'gigas-text' in x or 'data-info' in x))\n",
        "                if ilimitado_tag and (\"ilimitado\" in ilimitado_tag.get_text().lower() or \"sin límites\" in ilimitado_tag.get_text().lower()):\n",
        "                    gigas = \"Ilimitados\"\n",
        "                    detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                else:\n",
        "                    text_content_lower = plan_element.get_text(separator=' ', strip=True).lower()\n",
        "                    if \"ilimitado\" in text_content_lower and (\"datos\" in text_content_lower or \"gigas\" in text_content_lower):\n",
        "                        gigas = \"Ilimitados\"\n",
        "                        detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                    else:\n",
        "                        match_gb = re.search(r'(\\d+)\\s*gb', text_content_lower)\n",
        "                        if match_gb:\n",
        "                            gigas = f\"{match_gb.group(1)} GB\"\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "                        else:\n",
        "                            match_bono_gb = re.search(r'(bono\\s*\\d+\\s*gb\\s*x\\s*\\d+\\s*meses)', text_content_lower)\n",
        "                            if match_bono_gb:\n",
        "                                gigas = match_bono_gb.group(1).replace('x', 'x ')\n",
        "                                detalles_gigas = \"Bono de Gigas\"\n",
        "\n",
        "            apps_ttl_tag = plan_element.find('p', class_='p-plan__slide__apps__ttl')\n",
        "            if apps_ttl_tag:\n",
        "                apps_ilimitadas = apps_ttl_tag.get_text(strip=True)\n",
        "                apps_ilimitadas = re.sub(r'\\s*\\n\\s*', ' ', apps_ilimitadas).strip()\n",
        "            else:\n",
        "                apps_ilimitadas_list_temp = []\n",
        "                apps_container = plan_element.find('div', class_='p-plan__slide__apps')\n",
        "                if apps_container:\n",
        "                    app_elements = apps_container.find_all(['img', 'span', 'i', 'p'], class_=lambda x: x and ('app-icon' in x or 'unlimited-app-icon' in x or 'logo-app' in x or 'app-name' in x))\n",
        "                    for app_el in app_elements:\n",
        "                        app_name = app_el.get('alt') or app_el.get('title') or app_el.get_text(strip=True)\n",
        "                        if app_name and app_name.strip():\n",
        "                            apps_ilimitadas_list_temp.append(re.sub(r'\\s*\\n\\s*', ' ', app_name).strip())\n",
        "\n",
        "                if not apps_ilimitadas_list_temp:\n",
        "                    text_content_full = plan_element.get_text(separator=' ', strip=True)\n",
        "                    match_apps_text = re.search(r'(?:Apps|Redes Sociales)\\s+Ilimitadas(?::\\s*(.*?))?(?=[.\\n]|$)', text_content_full, re.IGNORECASE | re.DOTALL)\n",
        "                    if match_apps_text:\n",
        "                        if match_apps_text.group(1):\n",
        "                            apps_ilimitadas_list_temp.extend([re.sub(r'\\s*\\n\\s*', ' ', app.strip()).strip() for app in match_apps_text.group(1).split(',') if app.strip()])\n",
        "                        else:\n",
        "                            apps_ilimitadas_list_temp.append(re.sub(r'\\s*\\n\\s*', ' ', match_apps_text.group(0).replace(\":\", \"\").strip()).strip())\n",
        "\n",
        "                    keywords = [\"WhatsApp\", \"Facebook\", \"Instagram\", \"TikTok\", \"Spotify\", \"Netflix\", \"Youtube\", \"Waze\", \"Twitter\"]\n",
        "                    for keyword in keywords:\n",
        "                        if f\"{keyword} Ilimitado\" in text_content_full or f\"Acceso ilimitado a {keyword}\" in text_content_full:\n",
        "                            if keyword.lower() not in [a.lower() for a in apps_ilimitadas_list_temp]:\n",
        "                                apps_ilimitadas_list_temp.append(keyword)\n",
        "\n",
        "                if apps_ilimitadas_list_temp:\n",
        "                    apps_ilimitadas = \", \".join(sorted(list(set(apps_ilimitadas_list_temp))))\n",
        "\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "\n",
        "            all_benefit_texts_raw = []\n",
        "            benefit_text_tags_specific = plan_element.find_all('p', class_='stefa-parrilla_blanco--body-texto')\n",
        "            for tag in benefit_text_tags_specific:\n",
        "                all_benefit_texts_raw.append(tag.get_text(strip=True))\n",
        "\n",
        "            details_container = plan_element.find('div', class_='p-plan__slide__details')\n",
        "            if details_container:\n",
        "                general_benefit_tags = details_container.find_all(['li', 'p', 'span', 'div'], class_=lambda x: x and ('benefit-item' in x or 'feature-row' in x or 'text-benefit' in x or 'item-detail' in x or 'body-text' in x or 'plan-detail' in x))\n",
        "                for tag in general_benefit_tags:\n",
        "                    all_benefit_texts_raw.append(tag.get_text(strip=True))\n",
        "\n",
        "            full_plan_text = plan_element.get_text(separator=' ', strip=True)\n",
        "            all_benefit_texts_raw.append(full_plan_text)\n",
        "\n",
        "            processed_texts = set()\n",
        "\n",
        "            for raw_text in all_benefit_texts_raw:\n",
        "                cleaned_text = re.sub(r'\\s*\\n\\s*', ' ', raw_text).strip()\n",
        "                if not cleaned_text or cleaned_text in processed_texts:\n",
        "                    continue\n",
        "                processed_texts.add(cleaned_text)\n",
        "\n",
        "                text_lower = cleaned_text.lower()\n",
        "\n",
        "                if 'llamadas ilimitadas' in text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas'\n",
        "                    match_usa_canada = re.search(r'(\\d+)\\s*minutos\\s*(?:para|a)\\s*(?:usa|eeuu)\\s*(?:y|e)\\s*canadá', text_lower)\n",
        "                    if match_usa_canada:\n",
        "                        minutos_llamadas += f\", {match_usa_canada.group(1)} minutos para Usa y Canadá\"\n",
        "                elif re.search(r'(\\d+)\\s*minutos', text_lower):\n",
        "                    match_minutes = re.search(r'(\\d+)\\s*minutos', text_lower)\n",
        "                    if match_minutes:\n",
        "                        minutos_llamadas = f\"{match_minutes.group(1)} minutos\"\n",
        "\n",
        "                if 'sms ilimitados' in text_lower:\n",
        "                    sms = 'SMS ilimitados'\n",
        "                elif re.search(r'(\\d+)\\s*sms', text_lower):\n",
        "                    match_sms = re.search(r'(\\d+)\\s*sms', text_lower)\n",
        "                    if match_sms:\n",
        "                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "\n",
        "            if \"internet + llamadas ilimitadas\" in apps_ilimitadas.lower() and minutos_llamadas == 'No especificado':\n",
        "                minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                apps_ilimitadas = apps_ilimitadas.replace(\"Internet + Llamadas Ilimitadas\", \"Internet Ilimitado (si aplica)\").strip()\n",
        "                if not apps_ilimitadas or apps_ilimitadas.lower() == \"internet ilimitado (si aplica)\".lower():\n",
        "                    apps_ilimitadas = 'No especificado'\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratación': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la extracción de Movistar: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def extraer_planes_claro_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Claro.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://www.claro.com.pe/personas/movil/postpago/\"\n",
        "    plans_data = []\n",
        "    processed_plans = set()\n",
        "\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1920,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "\n",
        "    driver = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        wait = WebDriverWait(driver, 20)\n",
        "        wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'cA1PEBodyCardWrap')))\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='cA1PEBodyCardWrap')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR (Claro): No se encontraron elementos de planes en la página. La estructura HTML podría haber cambiado.\")\n",
        "            return []\n",
        "\n",
        "        for plan_element in plan_elements:\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            name = plan_element.get('data-badge', 'N/A')\n",
        "            nombre_plan = name\n",
        "\n",
        "            price_str = plan_element.get('data-price', 'N/A')\n",
        "            try:\n",
        "                precio = float(price_str)\n",
        "            except ValueError:\n",
        "                precio = 'N/A'\n",
        "\n",
        "            plan_key = (nombre_plan, precio)\n",
        "            if plan_key in processed_plans:\n",
        "                continue\n",
        "            processed_plans.add(plan_key)\n",
        "\n",
        "            gigas_tag = plan_element.find('span', class_='number')\n",
        "            if gigas_tag:\n",
        "                gigas_text = gigas_tag.get_text(strip=True)\n",
        "                if gigas_text.upper().endswith('GB'):\n",
        "                    gigas = gigas_text\n",
        "                    if \"ilimitado\" in plan_element.get_text().lower() or \"velocidad reducida\" in plan_element.get_text().lower():\n",
        "                        detalles_gigas = f\"{gigas} en Alta Velocidad (luego velocidad reducida)\"\n",
        "                    else:\n",
        "                        detalles_gigas = \"En Alta Velocidad\"\n",
        "                elif \"ilimitado\" in gigas_text.lower():\n",
        "                    gigas = \"Ilimitados\"\n",
        "                    detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                else:\n",
        "                    gigas = gigas_text\n",
        "                    detalles_gigas = \"N/A\"\n",
        "\n",
        "            is_max_ilimitado_promo = False\n",
        "            promo_div = plan_element.find('div', class_='cardPePromo')\n",
        "            if promo_div:\n",
        "                promo_text_span = promo_div.find('span', string=lambda text: text and 'Gigas, Minutos y SMS' in text)\n",
        "                if promo_text_span:\n",
        "                    is_max_ilimitado_promo = True\n",
        "                    minutos_llamadas = \"Ilimitadas\"\n",
        "                    sms = \"Ilimitados\"\n",
        "                    apps_ilimitadas = \"Incluidas en Todo Ilimitado\"\n",
        "\n",
        "            if not is_max_ilimitado_promo:\n",
        "                apps_list = []\n",
        "                app_icon_tags = plan_element.find_all('i', class_=lambda x: x and 'cIco-rs-' in x)\n",
        "                for icon_tag in app_icon_tags:\n",
        "                    for cls in icon_tag.get('class', []):\n",
        "                        if 'cIco-rs-' in cls:\n",
        "                            app_name = cls.replace('cIco-rs-', '')\n",
        "                            apps_list.append(app_name.capitalize())\n",
        "                apps_ilimitadas = \", \".join(apps_list) if apps_list else 'No especificado'\n",
        "                if apps_list:\n",
        "                    apps_ilimitadas = f\"{apps_ilimitadas} ilimitadas\"\n",
        "\n",
        "                if minutos_llamadas == 'No especificado':\n",
        "                    span_element_with_text = plan_element.find('span', string=lambda text: text and ('Llamadas y SMS' in text.strip() or 'Llamadas' in text.strip() or 'SMS' in text.strip()))\n",
        "                    if span_element_with_text:\n",
        "                        dt_parent = span_element_with_text.find_parent('dt')\n",
        "                        if dt_parent:\n",
        "                            dd_element = dt_parent.find_next_sibling('dd')\n",
        "                            if dd_element:\n",
        "                                calls_sms_text = dd_element.get_text(strip=True)\n",
        "                                if \"ilimitadas\" in calls_sms_text.lower():\n",
        "                                    minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                                    sms = \"SMS ilimitados\"\n",
        "                                else:\n",
        "                                    match_minutes = re.search(r'(\\d+)\\s*minutos', calls_sms_text, re.IGNORECASE)\n",
        "                                    if match_minutes:\n",
        "                                        minutos_llamadas = f\"{match_minutes.group(1)} minutos\"\n",
        "                                    else:\n",
        "                                        minutos_llamadas = calls_sms_text\n",
        "                                    match_sms = re.search(r'(\\d+)\\s*sms', calls_sms_text, re.IGNORECASE)\n",
        "                                    if match_sms:\n",
        "                                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "                                    else:\n",
        "                                        sms = calls_sms_text\n",
        "\n",
        "            plans_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratacion': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la extracción de Claro: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return plans_data\n",
        "\n",
        "def extraer_planes_bitel_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Bitel.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes.\n",
        "    \"\"\"\n",
        "    url = \"https://bitel.com.pe/planes/control/ilimitado\"\n",
        "    planes_data = []\n",
        "\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1990,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "    options.add_experimental_option('excludeSwitches', ['enable-logging'])\n",
        "\n",
        "    driver = None\n",
        "    wait = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        wait = WebDriverWait(driver, 45)\n",
        "\n",
        "        try:\n",
        "            common_close_xpaths = [\n",
        "                \"//button[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'Cerrar') or contains(., 'OK')]\",\n",
        "                \"//a[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'Cerrar') or contains(., 'OK')]\",\n",
        "                \"//div[contains(@class, 'close-button') or contains(@class, 'modal-close') or contains(@class, 'btn-close') or contains(@class, 'close-popup')]\",\n",
        "                \"//span[contains(text(), 'x') or contains(text(), 'X') or @class='close-icon']\",\n",
        "                \"//button[contains(@id, 'cookie') or contains(@id, 'modal') or contains(@class, 'cookie') or contains(@class, 'modal')][contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'OK')]\",\n",
        "                \"//div[@role='dialog']//button[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'OK')]\"\n",
        "            ]\n",
        "\n",
        "            found_and_clicked = False\n",
        "            for xpath_str in common_close_xpaths:\n",
        "                try:\n",
        "                    btn = WebDriverWait(driver, 5).until(\n",
        "                        EC.element_to_be_clickable((By.XPATH, xpath_str))\n",
        "                    )\n",
        "                    if btn.is_displayed() and btn.is_enabled():\n",
        "                        btn.click()\n",
        "                        time.sleep(2)\n",
        "                        found_and_clicked = True\n",
        "                        break\n",
        "                except:\n",
        "                    pass\n",
        "\n",
        "        except Exception as e:\n",
        "            pass\n",
        "\n",
        "        try:\n",
        "            wait.until(EC.visibility_of_element_located((By.CLASS_NAME, 'cont-package')))\n",
        "        except Exception as e:\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight/2);\")\n",
        "            time.sleep(3)\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n",
        "            time.sleep(5)\n",
        "\n",
        "            try:\n",
        "                wait.until(EC.visibility_of_element_located((By.CLASS_NAME, 'cont-package')))\n",
        "            except Exception as e:\n",
        "                print(f\"ERROR FATAL: 'cont-package' no se hizo visible incluso después de scroll. {e}\")\n",
        "                print(\"La estructura de la página o la forma en que carga el contenido ha cambiado significativamente o hay un bloqueo persistente.\")\n",
        "                return []\n",
        "\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='cont-package')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR: Después de la carga, no se encontraron elementos con la clase 'cont-package' en BeautifulSoup.\")\n",
        "            print(\"Esto podría indicar que la clase ha cambiado o el contenido no está en el HTML parseado.\")\n",
        "            return []\n",
        "\n",
        "        for i, plan_element in enumerate(plan_elements):\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            detalles_gigas = 'N/A'\n",
        "\n",
        "            full_plan_text_raw = plan_element.get_text(separator=' ', strip=True)\n",
        "            full_plan_text_lower = full_plan_text_raw.lower()\n",
        "\n",
        "            match_precio = re.search(r's/\\s*(\\d+\\.\\d+)', full_plan_text_lower)\n",
        "            if match_precio:\n",
        "                precio = f\"S/ {match_precio.group(1)}\"\n",
        "            else:\n",
        "                price_element_a = plan_element.find('a', href=\"javascript:void(0);\")\n",
        "                if price_element_a:\n",
        "                    title_attr = price_element_a.get('title')\n",
        "                    if title_attr:\n",
        "                        match_price_title = re.search(r'(\\d+\\.\\d+)', title_attr)\n",
        "                        if match_price_title:\n",
        "                            precio = f\"S/ {match_price_title.group(1)}\"\n",
        "\n",
        "                if precio == 'N/A':\n",
        "                    match_precio_simple = re.search(r'(\\d+\\.\\d+)', full_plan_text_lower)\n",
        "                    if match_precio_simple:\n",
        "                        precio_val = float(match_precio_simple.group(1))\n",
        "                        if 10.00 <= precio_val <= 200.00:\n",
        "                            precio = f\"S/ {match_precio_simple.group(1)}\"\n",
        "\n",
        "            if precio != 'N/A':\n",
        "                nombre_plan = f\"Ilimitado - {precio.replace('S/ ', '')}\"\n",
        "            else:\n",
        "                name_span_element = plan_element.find('span', class_='color-white text-bold title-1g')\n",
        "                if name_span_element:\n",
        "                    span_text = name_span_element.get_text(strip=True)\n",
        "                    cleaned_span_text = re.sub(r'\\s*S/\\s*\\d+\\.\\d+', '', span_text, flags=re.IGNORECASE).strip()\n",
        "                    cleaned_span_text = re.sub(r'\\s*\\d+\\.\\d+$', '', cleaned_span_text, flags=re.IGNORECASE).strip()\n",
        "                    if cleaned_span_text:\n",
        "                        nombre_plan = f\"Ilimitado - {cleaned_span_text}\"\n",
        "                    else:\n",
        "                        nombre_plan = \"Ilimitado - Precio No Disponible\"\n",
        "                else:\n",
        "                    nombre_plan = \"Ilimitado - Precio No Disponible\"\n",
        "\n",
        "            gigas_element = plan_element.find('p', class_='capa')\n",
        "\n",
        "            if gigas_element:\n",
        "                gigas_text = gigas_element.get_text(strip=True)\n",
        "                gigas_text_lower = gigas_text.lower()\n",
        "\n",
        "                period_element = plan_element.find('p', class_='period')\n",
        "                period_text_lower = period_element.get_text(strip=True).lower() if period_element else ''\n",
        "\n",
        "                if 'ilimitados' in gigas_text_lower:\n",
        "                    gigas = 'Ilimitados'\n",
        "                    match_gigas_alta_velocidad = re.search(r'(\\d+)\\s*GB(?:\\s*en\\s*alta\\s*velocidad)?', gigas_text, re.IGNORECASE)\n",
        "                    if match_gigas_alta_velocidad:\n",
        "                        detalles_gigas = f\"{match_gigas_alta_velocidad.group(1)} GB en Alta Velocidad\"\n",
        "                    elif 'alta velocidad' in period_text_lower:\n",
        "                        detalles_gigas = \"Velocidad reducida después de cierto consumo\"\n",
        "                    else:\n",
        "                        detalles_gigas = \"Datos ilimitados sin restricciones de velocidad explícitas\"\n",
        "                else:\n",
        "                    match_gigas = re.search(r'(\\d+)\\s*GB', gigas_text, re.IGNORECASE)\n",
        "                    if match_gigas:\n",
        "                        gigas = f\"{match_gigas.group(1)} GB\"\n",
        "                        if 'alta velocidad' in period_text_lower:\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "                    else:\n",
        "                        gigas = gigas_text\n",
        "                        if 'alta velocidad' in period_text_lower:\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "            else:\n",
        "                gigas = 'N/A'\n",
        "                detalles_gigas = 'Elemento de gigas no encontrado'\n",
        "\n",
        "            app_keywords_patterns = {\n",
        "                'WhatsApp': r'whatsapp ilimitado',\n",
        "                'Facebook': r'facebook ilimitado',\n",
        "                'Instagram': r'instagram ilimitado',\n",
        "                'TikTok': r'tiktok ilimitado',\n",
        "                'Spotify': r'spotify ilimitado',\n",
        "                'Waze': r'waze ilimitado',\n",
        "                'YouTube': r'youtube ilimitado',\n",
        "                'Apps ilimitadas x meses': r'apps ilimitadas (x \\d+ meses)?',\n",
        "                'Internet + Llamadas ilimitadas': r'internet \\+\\s*llamadas ilimitadas'\n",
        "            }\n",
        "            found_apps = []\n",
        "            for app_name, pattern in app_keywords_patterns.items():\n",
        "                if re.search(pattern, full_plan_text_lower):\n",
        "                    if 'x \\d+ meses' in pattern and re.search(r'x \\d+ meses', full_plan_text_lower):\n",
        "                        promo_match = re.search(r'x \\d+ meses', full_plan_text_lower).group(0)\n",
        "                        found_apps.append(f\"{app_name.replace(' x meses', '')} {promo_match}\")\n",
        "                    else:\n",
        "                        found_apps.append(app_name)\n",
        "\n",
        "            app_image_elements = plan_element.find_all('li', class_='app-item')\n",
        "            for app_li in app_image_elements:\n",
        "                img_tag = app_li.find('img')\n",
        "                if img_tag and 'alt' in img_tag.attrs:\n",
        "                    app_name_from_alt = img_tag['alt'].strip()\n",
        "                    if app_name_from_alt and app_name_from_alt.lower() not in [app.lower() for app in found_apps]:\n",
        "                        found_apps.append(app_name_from_alt)\n",
        "\n",
        "            apps_ilimitadas = \", \".join(sorted(list(set(found_apps)))) if found_apps else 'No especificado'\n",
        "\n",
        "            minutos_llamadas = \"No especificado\"\n",
        "            sms = \"No especificado\"\n",
        "\n",
        "            todo_ilimitado_element = plan_element.find('p', class_=re.compile(r'title.*Todo ilimitado'))\n",
        "            if todo_ilimitado_element and \"todo ilimitado\" in todo_ilimitado_element.get_text(strip=True).lower():\n",
        "                minutos_llamadas = 'Llamadas ilimitadas'\n",
        "                sms = 'SMS ilimitados'\n",
        "            else:\n",
        "                if 'llamadas ilimitadas perú' in full_plan_text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas Perú'\n",
        "                    match_usa_canada = re.search(r'(\\d+)\\s*minutos\\s*(?:para|a)\\s*(?:usa|eeuu)\\s*(?:y|e)\\s*canadá', full_plan_text_lower)\n",
        "                    if match_usa_canada:\n",
        "                        minutos_llamadas += f\", {match_usa_canada.group(1)} minutos para Usa y Canadá\"\n",
        "                elif 'llamadas ilimitadas' in full_plan_text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas'\n",
        "\n",
        "                if 'sms ilimitados' in full_plan_text_lower:\n",
        "                    sms = 'SMS ilimitados'\n",
        "                else:\n",
        "                    match_sms = re.search(r'(\\d+)\\s*sms', full_plan_text_lower)\n",
        "                    if match_sms:\n",
        "                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "\n",
        "            benefit_period_element = plan_element.find('p', class_='benefit-period')\n",
        "            if benefit_period_element and \"internet, llamadas y sms\" in benefit_period_element.get_text(strip=True).lower():\n",
        "                if minutos_llamadas == \"No especificado\":\n",
        "                    minutos_llamadas = 'Llamadas incluidas'\n",
        "                if sms == \"No especificado\":\n",
        "                    sms = 'SMS incluidos'\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratación': 'Postpago',\n",
        "                'Vigencia de Promoción': 'N/A'\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la ejecución: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def extraer_planes_entel_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Entel.\n",
        "    Este código usa requests y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://ofertasentel.pe/?utm_source=bing&utm_medium=cpc_search&utm_campaign=pospago_promo_marcaplanes&utm_term=marca_planes&utmcampaign=0104020302&msclkid=dfab6aa18cde18a17c3b02cd920ff43b\"\n",
        "    planes_data = []\n",
        "\n",
        "    headers = {\n",
        "        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n",
        "    }\n",
        "\n",
        "    try:\n",
        "        response = requests.get(url, headers=headers, timeout=15)\n",
        "        response.raise_for_status()\n",
        "\n",
        "        soup = BeautifulSoup(response.content, 'html.parser')\n",
        "\n",
        "        plan_boxes = soup.find_all('div', class_='box')\n",
        "\n",
        "        if not plan_boxes:\n",
        "            print(\"ERROR (Entel): No se encontraron elementos con la clase 'box' en BeautifulSoup.\")\n",
        "            return []\n",
        "\n",
        "        for box in plan_boxes:\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            plan_name_tag = box.find('div', class_='property property_internet')\n",
        "            if plan_name_tag and plan_name_tag.find('b'):\n",
        "                nombre_plan = plan_name_tag.find('b').get_text(strip=True)\n",
        "            elif box.find('h3'):\n",
        "                nombre_plan = box.find('h3').get_text(strip=True)\n",
        "\n",
        "            price_tag = box.find('div', class_='price')\n",
        "            if price_tag:\n",
        "                precio = price_tag.get_text(strip=True)\n",
        "\n",
        "            gb_div = box.find('div', class_='gb')\n",
        "            if gb_div:\n",
        "                strong_text = gb_div.find('strong').get_text(strip=True) if gb_div.find('strong') else ''\n",
        "                span_text = gb_div.find('span').get_text(strip=True) if gb_div.find('span') else ''\n",
        "\n",
        "                if 'ilimitado' in strong_text.lower():\n",
        "                    gigas = 'Ilimitados'\n",
        "                    if span_text:\n",
        "                        detalles_gigas = span_text.strip()\n",
        "                    else:\n",
        "                        detalles_gigas = \"Datos ilimitados sin restricciones de velocidad explícitas\"\n",
        "                else:\n",
        "                    gigas = strong_text.strip()\n",
        "                    if span_text:\n",
        "                        detalles_gigas = span_text.strip()\n",
        "                    else:\n",
        "                        detalles_gigas = \"N/A\"\n",
        "\n",
        "            app_tag = box.find('div', class_='property property_app')\n",
        "            if app_tag:\n",
        "                app_list_items = app_tag.find_all('li')\n",
        "                if app_list_items:\n",
        "                    apps_ilimitadas = \", \".join(sorted(list(set([li.get_text(strip=True) for li in app_list_items if li.get_text(strip=True)]))))\n",
        "                else:\n",
        "                    apps_ilimitadas = app_tag.get_text(strip=True, separator=' ')\n",
        "                if \"ilimitado\" not in apps_ilimitadas.lower() and \"ilimitadas\" not in apps_ilimitadas.lower() and apps_ilimitadas != 'N/A' and apps_ilimitadas != 'No especificado':\n",
        "                     apps_ilimitadas = f\"{apps_ilimitadas} ilimitadas\"\n",
        "\n",
        "            llamadas_tag = box.find('div', class_='property property_llamadas')\n",
        "            if llamadas_tag:\n",
        "                llamadas_text = llamadas_tag.get_text(strip=True)\n",
        "                if \"ilimitadas\" in llamadas_text.lower():\n",
        "                    minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                else:\n",
        "                    minutos_llamadas = llamadas_text\n",
        "\n",
        "            sms_tag = box.find('div', class_='property property_sms')\n",
        "            if sms_tag:\n",
        "                sms_text = sms_tag.get_text(strip=True)\n",
        "                if \"ilimitados\" in sms_text.lower():\n",
        "                    sms = \"SMS ilimitados\"\n",
        "                else:\n",
        "                    sms = sms_text\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratacion': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except requests.exceptions.RequestException as e:\n",
        "        print(f\"Error de red al acceder a la página de Entel: {e}\")\n",
        "        return []\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error inesperado durante el scraping de Entel: {e}\")\n",
        "        return []\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def standardize_plan_data(plan):\n",
        "    \"\"\"\n",
        "    Estandariza las claves y los tipos de datos de un diccionario de plan.\n",
        "    Asegura que 'Precio (S/)' sea un float.\n",
        "    \"\"\"\n",
        "    # Definir todas las claves esperadas y sus valores por defecto\n",
        "    standardized_plan = {\n",
        "        'Operador': plan.get('Operador', 'N/A'),\n",
        "        'Nombre del Plan': plan.get('Nombre del Plan', 'N/A'),\n",
        "        'Precio (S/)': plan.get('Precio (S/)', 'N/A'),\n",
        "        'Gigas': plan.get('Gigas', 'N/A'),\n",
        "        'Detalles de Gigas': plan.get('Detalles de Gigas', 'N/A'),\n",
        "        'Apps Ilimitadas': plan.get('Apps Ilimitadas', 'No especificado'),\n",
        "        'Minutos/Llamadas': plan.get('Minutos/Llamadas', 'No especificado'),\n",
        "        'SMS': plan.get('SMS', 'No especificado'),\n",
        "        'Tipo de Contratación': plan.get('Tipo de Contratación', 'Postpago'),\n",
        "        'Vigencia de Promoción': plan.get('Vigencia de Promoción', 'N/A')\n",
        "    }\n",
        "\n",
        "    # Convertir Precio (S/) a float\n",
        "    precio_raw = standardized_plan['Precio (S/)']\n",
        "    if isinstance(precio_raw, str):\n",
        "        precio_str = precio_raw.replace('S/', '').replace(',', '.').strip()\n",
        "        try:\n",
        "            standardized_plan['Precio (S/)'] = float(precio_str)\n",
        "        except ValueError:\n",
        "            standardized_plan['Precio (S/)'] = None # Usar None si no se puede convertir a número\n",
        "    elif not isinstance(precio_raw, (int, float)):\n",
        "        standardized_plan['Precio (S/)'] = None # Asegurarse de que sea None si no es número ni string convertible\n",
        "\n",
        "    return standardized_plan\n",
        "\n",
        "def get_all_telecom_plans():\n",
        "    \"\"\"\n",
        "    Extrae y combina los planes de todos los operadores.\n",
        "    Retorna un DataFrame de Pandas con los datos estandarizados.\n",
        "    \"\"\"\n",
        "    all_plans = []\n",
        "\n",
        "    # --- Extraer y combinar planes de Movistar ---\n",
        "    try:\n",
        "        movistar_plans = extraer_planes_movistar_colab()\n",
        "        for plan in movistar_plans:\n",
        "            plan['Operador'] = 'Movistar'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Movistar: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Claro ---\n",
        "    try:\n",
        "        claro_plans = extraer_planes_claro_colab()\n",
        "        for plan in claro_plans:\n",
        "            plan['Operador'] = 'Claro'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Claro: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Bitel ---\n",
        "    try:\n",
        "        bitel_plans = extraer_planes_bitel_colab()\n",
        "        for plan in bitel_plans:\n",
        "            plan['Operador'] = 'Bitel'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Bitel: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Entel ---\n",
        "    try:\n",
        "        entel_plans = extraer_planes_entel_colab()\n",
        "        for plan in entel_plans:\n",
        "            plan['Operador'] = 'Entel'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Entel: {e}\")\n",
        "\n",
        "    df = pd.DataFrame(all_plans)\n",
        "\n",
        "    # Ordenar por precio, asegurando que los valores 'N/A' o None vayan al final\n",
        "    df['Precio_Sort'] = df['Precio (S/)'].apply(lambda x: x if isinstance(x, (int, float)) else float('inf'))\n",
        "    df_sorted = df.sort_values(by='Precio_Sort').drop(columns='Precio_Sort')\n",
        "\n",
        "    return df_sorted\n",
        "\n",
        "# --- Inicializar la aplicación Dash ---\n",
        "app = dash.Dash(__name__)\n",
        "\n",
        "# Cargar los datos iniciales\n",
        "df_plans = get_all_telecom_plans()\n",
        "\n",
        "# Obtener opciones únicas de operadores para el dropdown\n",
        "operator_options = [{'label': 'Todos', 'value': 'all'}] + \\\n",
        "                   [{'label': op, 'value': op} for op in df_plans['Operador'].unique()]\n",
        "\n",
        "# --- Diseño de la aplicación Dash ---\n",
        "app.layout = html.Div(style={'fontFamily': 'Arial, sans-serif', 'padding': '20px', 'backgroundColor': '#f4f4f4', 'color': '#333'}, children=[\n",
        "    html.H1(\"Comparador de Planes Telefónicos\", style={'textAlign': 'center', 'color': '#007bff'}),\n",
        "\n",
        "    html.Div([\n",
        "        html.Label(\"Filtrar por Operador:\", style={'marginRight': '10px', 'fontWeight': 'bold'}),\n",
        "        dcc.Dropdown(\n",
        "            id='operator-dropdown',\n",
        "            options=operator_options,\n",
        "            value='all',\n",
        "            clearable=False,\n",
        "            style={'width': '200px', 'display': 'inline-block', 'verticalAlign': 'middle'}\n",
        "        ),\n",
        "    ], style={'marginBottom': '20px', 'textAlign': 'center'}),\n",
        "\n",
        "    dash_table.DataTable(\n",
        "        id='plans-table',\n",
        "        columns=[{\"name\": i, \"id\": i} for i in df_plans.columns],\n",
        "        data=df_plans.to_dict('records'),\n",
        "        style_table={'overflowX': 'auto', 'boxShadow': '0 4px 12px rgba(0,0,0,0.15)', 'borderRadius': '8px'},\n",
        "        style_header={\n",
        "            'backgroundColor': '#00AEEF',\n",
        "            'color': 'white',\n",
        "            'fontWeight': 'bold',\n",
        "            'textAlign': 'left',\n",
        "            'padding': '15px 20px',\n",
        "            'textTransform': 'uppercase',\n",
        "            'fontSize': '0.95em',\n",
        "            'letterSpacing': '0.5px'\n",
        "        },\n",
        "        style_data={\n",
        "            'backgroundColor': 'white',\n",
        "            'color': '#333',\n",
        "            'borderBottom': '1px solid #eee',\n",
        "            'padding': '15px 20px'\n",
        "        },\n",
        "        style_data_conditional=[\n",
        "            {\n",
        "                'if': {'row_index': 'even'},\n",
        "                'backgroundColor': '#f8f8f8'\n",
        "            },\n",
        "            {\n",
        "                'if': {'state': 'active'},\n",
        "                'backgroundColor': '#e0f7fa',\n",
        "                'border': '1px solid #00AEEF'\n",
        "            }\n",
        "        ],\n",
        "        filter_action=\"native\",\n",
        "        sort_action=\"native\",\n",
        "        page_action=\"native\",\n",
        "        page_size=10,\n",
        "    )\n",
        "])\n",
        "\n",
        "# --- Callbacks para interactividad ---\n",
        "@app.callback(\n",
        "    Output('plans-table', 'data'),\n",
        "    Input('operator-dropdown', 'value')\n",
        ")\n",
        "def update_table(selected_operator):\n",
        "    if selected_operator == 'all':\n",
        "        return df_plans.to_dict('records')\n",
        "    else:\n",
        "        filtered_df = df_plans[df_plans['Operador'] == selected_operator]\n",
        "        return filtered_df.to_dict('records')\n",
        "\n",
        "# --- Ejecutar la aplicación Dash en Colab ---\n",
        "if __name__ == '__main__':\n",
        "    app.run_server(mode='inline', port=8050)\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "KpcePVBEOcEo",
        "outputId": "3ccf9067-c61d-4226-d816-13257f6c2bf2"
      },
      "execution_count": 1,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome-archive-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main\n",
            "Get:1 http://dl.google.com/linux/chrome/deb stable InRelease [1,825 B]\n",
            "Get:2 https://cloud.r-project.org/bin/linux/ubuntu jammy-cran40/ InRelease [3,632 B]\n",
            "Hit:3 https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64  InRelease\n",
            "Get:4 http://dl.google.com/linux/chrome/deb stable/main amd64 Packages [1,215 B]\n",
            "Get:5 http://security.ubuntu.com/ubuntu jammy-security InRelease [129 kB]\n",
            "Hit:6 http://archive.ubuntu.com/ubuntu jammy InRelease\n",
            "Get:7 https://r2u.stat.illinois.edu/ubuntu jammy InRelease [6,555 B]\n",
            "Get:8 http://archive.ubuntu.com/ubuntu jammy-updates InRelease [128 kB]\n",
            "Hit:9 https://ppa.launchpadcontent.net/deadsnakes/ppa/ubuntu jammy InRelease\n",
            "Get:10 https://r2u.stat.illinois.edu/ubuntu jammy/main all Packages [9,092 kB]\n",
            "Hit:11 https://ppa.launchpadcontent.net/graphics-drivers/ppa/ubuntu jammy InRelease\n",
            "Hit:12 https://ppa.launchpadcontent.net/ubuntugis/ppa/ubuntu jammy InRelease\n",
            "Get:13 http://archive.ubuntu.com/ubuntu jammy-backports InRelease [127 kB]\n",
            "Get:14 http://security.ubuntu.com/ubuntu jammy-security/main amd64 Packages [3,103 kB]\n",
            "Get:15 https://r2u.stat.illinois.edu/ubuntu jammy/main amd64 Packages [2,757 kB]\n",
            "Get:16 http://archive.ubuntu.com/ubuntu jammy-updates/universe amd64 Packages [1,569 kB]\n",
            "Get:17 http://security.ubuntu.com/ubuntu jammy-security/universe amd64 Packages [1,266 kB]\n",
            "Get:18 http://archive.ubuntu.com/ubuntu jammy-updates/main amd64 Packages [3,420 kB]\n",
            "Get:19 http://archive.ubuntu.com/ubuntu jammy-updates/restricted amd64 Packages [4,963 kB]\n",
            "Get:20 http://archive.ubuntu.com/ubuntu jammy-backports/universe amd64 Packages [35.2 kB]\n",
            "Get:21 http://archive.ubuntu.com/ubuntu jammy-backports/main amd64 Packages [83.2 kB]\n",
            "Fetched 26.7 MB in 3s (8,331 kB/s)\n",
            "Reading package lists... Done\n",
            "W: Skipping acquire of configured file 'main/source/Sources' as repository 'https://r2u.stat.illinois.edu/ubuntu jammy InRelease' does not seem to provide it (sources.list entry misspelt?)\n",
            "Reading package lists... Done\n",
            "Building dependency tree... Done\n",
            "Reading state information... Done\n",
            "The following additional packages will be installed:\n",
            "  libvulkan1 mesa-vulkan-drivers\n",
            "The following NEW packages will be installed:\n",
            "  google-chrome-stable libvulkan1 mesa-vulkan-drivers\n",
            "0 upgraded, 3 newly installed, 0 to remove and 39 not upgraded.\n",
            "Need to get 129 MB of archives.\n",
            "After this operation, 437 MB of additional disk space will be used.\n",
            "Get:1 http://dl.google.com/linux/chrome/deb stable/main amd64 google-chrome-stable amd64 138.0.7204.100-1 [118 MB]\n",
            "Get:2 http://archive.ubuntu.com/ubuntu jammy/main amd64 libvulkan1 amd64 1.3.204.1-2 [128 kB]\n",
            "Get:3 http://archive.ubuntu.com/ubuntu jammy-updates/main amd64 mesa-vulkan-drivers amd64 23.2.1-1ubuntu3.1~22.04.3 [10.7 MB]\n",
            "Fetched 129 MB in 2s (77.7 MB/s)\n",
            "debconf: unable to initialize frontend: Dialog\n",
            "debconf: (No usable dialog-like program is installed, so the dialog based frontend cannot be used. at /usr/share/perl5/Debconf/FrontEnd/Dialog.pm line 78, <> line 3.)\n",
            "debconf: falling back to frontend: Readline\n",
            "debconf: unable to initialize frontend: Readline\n",
            "debconf: (This frontend requires a controlling tty.)\n",
            "debconf: falling back to frontend: Teletype\n",
            "dpkg-preconfigure: unable to re-open stdin: \n",
            "Selecting previously unselected package libvulkan1:amd64.\n",
            "(Reading database ... 126281 files and directories currently installed.)\n",
            "Preparing to unpack .../libvulkan1_1.3.204.1-2_amd64.deb ...\n",
            "Unpacking libvulkan1:amd64 (1.3.204.1-2) ...\n",
            "Selecting previously unselected package google-chrome-stable.\n",
            "Preparing to unpack .../google-chrome-stable_138.0.7204.100-1_amd64.deb ...\n",
            "Unpacking google-chrome-stable (138.0.7204.100-1) ...\n",
            "Selecting previously unselected package mesa-vulkan-drivers:amd64.\n",
            "Preparing to unpack .../mesa-vulkan-drivers_23.2.1-1ubuntu3.1~22.04.3_amd64.deb ...\n",
            "Unpacking mesa-vulkan-drivers:amd64 (23.2.1-1ubuntu3.1~22.04.3) ...\n",
            "Setting up libvulkan1:amd64 (1.3.204.1-2) ...\n",
            "Setting up mesa-vulkan-drivers:amd64 (23.2.1-1ubuntu3.1~22.04.3) ...\n",
            "Setting up google-chrome-stable (138.0.7204.100-1) ...\n",
            "update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/x-www-browser (x-www-browser) in auto mode\n",
            "update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/gnome-www-browser (gnome-www-browser) in auto mode\n",
            "update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/google-chrome (google-chrome) in auto mode\n",
            "Processing triggers for man-db (2.10.2-1) ...\n",
            "Processing triggers for mailcap (3.70+nmu1ubuntu1) ...\n",
            "Processing triggers for libc-bin (2.35-0ubuntu3.8) ...\n",
            "/sbin/ldconfig.real: /usr/local/lib/libur_adapter_level_zero_v2.so.0 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbbbind_2_0.so.3 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbbmalloc_proxy.so.2 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbb.so.12 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libumf.so.0 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtcm_debug.so.1 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbbmalloc.so.2 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libur_loader.so.0 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libur_adapter_opencl.so.0 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbbbind.so.3 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libur_adapter_level_zero.so.0 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libhwloc.so.15 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtbbbind_2_5.so.3 is not a symbolic link\n",
            "\n",
            "/sbin/ldconfig.real: /usr/local/lib/libtcm.so.1 is not a symbolic link\n",
            "\n",
            "Google Chrome 138.0.7204.100 \n",
            "\n",
            "--- Instalación de Chrome y dependencias completada ---\n"
          ]
        },
        {
          "output_type": "error",
          "ename": "ObsoleteAttributeException",
          "evalue": "app.run_server has been replaced by app.run",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mObsoleteAttributeException\u001b[0m                Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-1-1703139851.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m    925\u001b[0m \u001b[0;31m# --- Ejecutar la aplicación Dash en Colab ---\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    926\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0m__name__\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m'__main__'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 927\u001b[0;31m     \u001b[0mapp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrun_server\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'inline'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mport\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m8050\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/dash/_obsolete.py\u001b[0m in \u001b[0;36m__getattr__\u001b[0;34m(self, name)\u001b[0m\n\u001b[1;32m     20\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mname\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_obsolete_attributes\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     21\u001b[0m             \u001b[0merr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_obsolete_attributes\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 22\u001b[0;31m             \u001b[0;32mraise\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0merr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     23\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__dict__\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mObsoleteAttributeException\u001b[0m: app.run_server has been replaced by app.run"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# --- PASO 0: REQUISITOS PREVIOS PARA GOOGLE COLAB ---\n",
        "# ¡IMPORTANTE!: Este bloque asegura que Google Chrome y las librerías necesarias estén instaladas.\n",
        "\n",
        "# Instalar Selenium, BeautifulSoup, Pandas y Webdriver Manager\n",
        "!pip install selenium beautifulsoup4 pandas webdriver-manager requests dash > /dev/null 2>&1\n",
        "\n",
        "# --- INSTALACIÓN DE GOOGLE CHROME EN COLAB ---\n",
        "# 1. Descargar la clave GPG de Google Chrome\n",
        "!wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-chrome-archive-keyring.gpg\n",
        "\n",
        "# 2. Añadir el repositorio de Google Chrome a las fuentes de apt\n",
        "!echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome-archive-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main\" | sudo tee /etc/apt/sources.list.d/google-chrome.list\n",
        "\n",
        "# 3. Actualizar los listados de paquetes apt para incluir el nuevo repositorio\n",
        "!sudo apt-get update\n",
        "\n",
        "# 4. Instalar Google Chrome estable\n",
        "!sudo apt-get install -y google-chrome-stable\n",
        "\n",
        "# Opcional: Verificar la versión de Chrome instalada\n",
        "!google-chrome --version\n",
        "\n",
        "print(\"\\n--- Instalación de Chrome y dependencias completada ---\")\n",
        "\n",
        "\n",
        "# --- PASO 2: IMPORTAR LIBRERÍAS ---\n",
        "from selenium import webdriver\n",
        "from selenium.webdriver.chrome.service import Service\n",
        "from selenium.webdriver.common.by import By\n",
        "from selenium.webdriver.support.ui import WebDriverWait\n",
        "from selenium.webdriver.support import expected_conditions as EC\n",
        "from bs4 import BeautifulSoup\n",
        "import time\n",
        "import pandas as pd\n",
        "import re\n",
        "\n",
        "from webdriver_manager.chrome import ChromeDriverManager\n",
        "import requests # Agregado para el scraping de Entel si usa requests\n",
        "\n",
        "import dash\n",
        "from dash import dcc\n",
        "from dash import html\n",
        "from dash.dependencies import Input, Output\n",
        "from dash import dash_table # Importar dash_table para la tabla de datos\n",
        "\n",
        "# --- TUS FUNCIONES REALES DE EXTRACCIÓN DE PLANES ---\n",
        "# ¡IMPORTANTE!: Estas funciones contienen el código de scraping para cada operador.\n",
        "# Asegúrate de que todas devuelvan una lista de diccionarios con un esquema consistente.\n",
        "\n",
        "def extraer_planes_movistar_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Movistar.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://www.movistar.com.pe/movil/postpago/planes-postpago\"\n",
        "    planes_data = []\n",
        "\n",
        "    # --- CONFIGURACIÓN DE SELENIUM PARA COLAB ---\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1920,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "    options.add_experimental_option('excludeSwitches', ['enable-logging'])\n",
        "\n",
        "    driver = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        # --- ESPERAR A QUE EL CONTENIDO DINÁMICO CARGUE ---\n",
        "        wait = WebDriverWait(driver, 30)\n",
        "        try:\n",
        "            wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'p-plan__slide__soles')))\n",
        "        except Exception as e:\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n",
        "            time.sleep(5)\n",
        "            try:\n",
        "                wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'p-plan__slide__soles')))\n",
        "            except Exception as e:\n",
        "                print(f\"ERROR (Movistar): 'p-plan__slide__soles' no se hizo visible incluso después de scroll. {e}\")\n",
        "                print(\"La estructura de la página o la forma en que carga el contenido ha cambiado significativamente o hay un bloqueo persistente.\")\n",
        "                return []\n",
        "\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='p-plan__slide__shadow')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR (Movistar): No se encontraron elementos con la clase 'p-plan__slide__shadow'.\")\n",
        "            print(\"Esto podría indicar que la clase ha cambiado nuevamente o el contenido no se cargó como se esperaba.\")\n",
        "            return []\n",
        "\n",
        "        for i, plan_element in enumerate(plan_elements):\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            precio_tag = plan_element.find('span', class_='p-plan__slide__soles')\n",
        "            if precio_tag:\n",
        "                precio = precio_tag.get_text(strip=True)\n",
        "\n",
        "            head_tag = plan_element.find('div', class_='p-plan__slide__head')\n",
        "            if head_tag:\n",
        "                name_tag = head_tag.find(['h3', 'h4', 'span', 'p'], class_=lambda x: x and ('p-plan__slide__name' in x or 'title' in x or 'plan-name' in x))\n",
        "                if name_tag:\n",
        "                    nombre_plan = name_tag.get_text(strip=True)\n",
        "                else:\n",
        "                    nombre_plan = ' '.join(head_tag.get_text(separator=' ', strip=True).split())\n",
        "\n",
        "                nombre_plan = re.sub(r'Plan Postpago\\s*', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'S/\\s*\\d+\\.\\d+', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'al mes', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'x \\d+ meses', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Precio regular:.*?(Ahorra \\d+%)?', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Bono \\d+ GB', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'Exclusivo online', '', nombre_plan, flags=re.IGNORECASE)\n",
        "                nombre_plan = re.sub(r'\\*', '', nombre_plan).strip()\n",
        "                nombre_plan = re.sub(r'\\s{2,}', ' ', nombre_plan).strip()\n",
        "\n",
        "                if not nombre_plan:\n",
        "                    nombre_plan = f\"Plan Postpago {precio}\" if precio != 'N/A' else 'Plan Postpago Desconocido'\n",
        "\n",
        "            gigas_cantidad_tag = plan_element.find('span', class_='p-plan__slide__cantidad')\n",
        "            if gigas_cantidad_tag:\n",
        "                extracted_gigas = gigas_cantidad_tag.get_text(strip=True).replace('\\n', ' ').strip()\n",
        "                if \"GB\" in extracted_gigas.upper() or re.match(r'^\\d+(\\.\\d+)?\\s*GB$', extracted_gigas, re.IGNORECASE):\n",
        "                    gigas = extracted_gigas\n",
        "                    detalles_gigas = \"En Alta Velocidad\"\n",
        "                elif \"Bono\" in extracted_gigas and \"GB\" in extracted_gigas:\n",
        "                    gigas = extracted_gigas\n",
        "                    detalles_gigas = \"Bono de Gigas\"\n",
        "\n",
        "            if gigas == 'N/A':\n",
        "                ilimitado_tag = plan_element.find(['span', 'div', 'h3', 'p'], class_=lambda x: x and ('p-plan__slide__gigas' in x or 'gigas-text' in x or 'data-info' in x))\n",
        "                if ilimitado_tag and (\"ilimitado\" in ilimitado_tag.get_text().lower() or \"sin límites\" in ilimitado_tag.get_text().lower()):\n",
        "                    gigas = \"Ilimitados\"\n",
        "                    detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                else:\n",
        "                    text_content_lower = plan_element.get_text(separator=' ', strip=True).lower()\n",
        "                    if \"ilimitado\" in text_content_lower and (\"datos\" in text_content_lower or \"gigas\" in text_content_lower):\n",
        "                        gigas = \"Ilimitados\"\n",
        "                        detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                    else:\n",
        "                        match_gb = re.search(r'(\\d+)\\s*gb', text_content_lower)\n",
        "                        if match_gb:\n",
        "                            gigas = f\"{match_gb.group(1)} GB\"\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "                        else:\n",
        "                            match_bono_gb = re.search(r'(bono\\s*\\d+\\s*gb\\s*x\\s*\\d+\\s*meses)', text_content_lower)\n",
        "                            if match_bono_gb:\n",
        "                                gigas = match_bono_gb.group(1).replace('x', 'x ')\n",
        "                                detalles_gigas = \"Bono de Gigas\"\n",
        "\n",
        "            apps_ttl_tag = plan_element.find('p', class_='p-plan__slide__apps__ttl')\n",
        "            if apps_ttl_tag:\n",
        "                apps_ilimitadas = apps_ttl_tag.get_text(strip=True)\n",
        "                apps_ilimitadas = re.sub(r'\\s*\\n\\s*', ' ', apps_ilimitadas).strip()\n",
        "            else:\n",
        "                apps_ilimitadas_list_temp = []\n",
        "                apps_container = plan_element.find('div', class_='p-plan__slide__apps')\n",
        "                if apps_container:\n",
        "                    app_elements = apps_container.find_all(['img', 'span', 'i', 'p'], class_=lambda x: x and ('app-icon' in x or 'unlimited-app-icon' in x or 'logo-app' in x or 'app-name' in x))\n",
        "                    for app_el in app_elements:\n",
        "                        app_name = app_el.get('alt') or app_el.get('title') or app_el.get_text(strip=True)\n",
        "                        if app_name and app_name.strip():\n",
        "                            apps_ilimitadas_list_temp.append(re.sub(r'\\s*\\n\\s*', ' ', app_name).strip())\n",
        "\n",
        "                if not apps_ilimitadas_list_temp:\n",
        "                    text_content_full = plan_element.get_text(separator=' ', strip=True)\n",
        "                    match_apps_text = re.search(r'(?:Apps|Redes Sociales)\\s+Ilimitadas(?::\\s*(.*?))?(?=[.\\n]|$)', text_content_full, re.IGNORECASE | re.DOTALL)\n",
        "                    if match_apps_text:\n",
        "                        if match_apps_text.group(1):\n",
        "                            apps_ilimitadas_list_temp.extend([re.sub(r'\\s*\\n\\s*', ' ', app.strip()).strip() for app in match_apps_text.group(1).split(',') if app.strip()])\n",
        "                        else:\n",
        "                            apps_ilimitadas_list_temp.append(re.sub(r'\\s*\\n\\s*', ' ', match_apps_text.group(0).replace(\":\", \"\").strip()).strip())\n",
        "\n",
        "                    keywords = [\"WhatsApp\", \"Facebook\", \"Instagram\", \"TikTok\", \"Spotify\", \"Netflix\", \"Youtube\", \"Waze\", \"Twitter\"]\n",
        "                    for keyword in keywords:\n",
        "                        if f\"{keyword} Ilimitado\" in text_content_full or f\"Acceso ilimitado a {keyword}\" in text_content_full:\n",
        "                            if keyword.lower() not in [a.lower() for a in apps_ilimitadas_list_temp]:\n",
        "                                apps_ilimitadas_list_temp.append(keyword)\n",
        "\n",
        "                if apps_ilimitadas_list_temp:\n",
        "                    apps_ilimitadas = \", \".join(sorted(list(set(apps_ilimitadas_list_temp))))\n",
        "\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "\n",
        "            all_benefit_texts_raw = []\n",
        "            benefit_text_tags_specific = plan_element.find_all('p', class_='stefa-parrilla_blanco--body-texto')\n",
        "            for tag in benefit_text_tags_specific:\n",
        "                all_benefit_texts_raw.append(tag.get_text(strip=True))\n",
        "\n",
        "            details_container = plan_element.find('div', class_='p-plan__slide__details')\n",
        "            if details_container:\n",
        "                general_benefit_tags = details_container.find_all(['li', 'p', 'span', 'div'], class_=lambda x: x and ('benefit-item' in x or 'feature-row' in x or 'text-benefit' in x or 'item-detail' in x or 'body-text' in x or 'plan-detail' in x))\n",
        "                for tag in general_benefit_tags:\n",
        "                    all_benefit_texts_raw.append(tag.get_text(strip=True))\n",
        "\n",
        "            full_plan_text = plan_element.get_text(separator=' ', strip=True)\n",
        "            all_benefit_texts_raw.append(full_plan_text)\n",
        "\n",
        "            processed_texts = set()\n",
        "\n",
        "            for raw_text in all_benefit_texts_raw:\n",
        "                cleaned_text = re.sub(r'\\s*\\n\\s*', ' ', raw_text).strip()\n",
        "                if not cleaned_text or cleaned_text in processed_texts:\n",
        "                    continue\n",
        "                processed_texts.add(cleaned_text)\n",
        "\n",
        "                text_lower = cleaned_text.lower()\n",
        "\n",
        "                if 'llamadas ilimitadas' in text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas'\n",
        "                    match_usa_canada = re.search(r'(\\d+)\\s*minutos\\s*(?:para|a)\\s*(?:usa|eeuu)\\s*(?:y|e)\\s*canadá', text_lower)\n",
        "                    if match_usa_canada:\n",
        "                        minutos_llamadas += f\", {match_usa_canada.group(1)} minutos para Usa y Canadá\"\n",
        "                elif re.search(r'(\\d+)\\s*minutos', text_lower):\n",
        "                    match_minutes = re.search(r'(\\d+)\\s*minutos', text_lower)\n",
        "                    if match_minutes:\n",
        "                        minutos_llamadas = f\"{match_minutes.group(1)} minutos\"\n",
        "\n",
        "                if 'sms ilimitados' in text_lower:\n",
        "                    sms = 'SMS ilimitados'\n",
        "                elif re.search(r'(\\d+)\\s*sms', text_lower):\n",
        "                    match_sms = re.search(r'(\\d+)\\s*sms', text_lower)\n",
        "                    if match_sms:\n",
        "                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "\n",
        "            if \"internet + llamadas ilimitadas\" in apps_ilimitadas.lower() and minutos_llamadas == 'No especificado':\n",
        "                minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                apps_ilimitadas = apps_ilimitadas.replace(\"Internet + Llamadas Ilimitadas\", \"Internet Ilimitado (si aplica)\").strip()\n",
        "                if not apps_ilimitadas or apps_ilimitadas.lower() == \"internet ilimitado (si aplica)\".lower():\n",
        "                    apps_ilimitadas = 'No especificado'\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratación': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la extracción de Movistar: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def extraer_planes_claro_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Claro.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://www.claro.com.pe/personas/movil/postpago/\"\n",
        "    plans_data = []\n",
        "    processed_plans = set()\n",
        "\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1920,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "\n",
        "    driver = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        wait = WebDriverWait(driver, 20)\n",
        "        wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'cA1PEBodyCardWrap')))\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='cA1PEBodyCardWrap')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR (Claro): No se encontraron elementos de planes en la página. La estructura HTML podría haber cambiado.\")\n",
        "            return []\n",
        "\n",
        "        for plan_element in plan_elements:\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            name = plan_element.get('data-badge', 'N/A')\n",
        "            nombre_plan = name\n",
        "\n",
        "            price_str = plan_element.get('data-price', 'N/A')\n",
        "            try:\n",
        "                precio = float(price_str)\n",
        "            except ValueError:\n",
        "                precio = 'N/A'\n",
        "\n",
        "            plan_key = (nombre_plan, precio)\n",
        "            if plan_key in processed_plans:\n",
        "                continue\n",
        "            processed_plans.add(plan_key)\n",
        "\n",
        "            gigas_tag = plan_element.find('span', class_='number')\n",
        "            if gigas_tag:\n",
        "                gigas_text = gigas_tag.get_text(strip=True)\n",
        "                if gigas_text.upper().endswith('GB'):\n",
        "                    gigas = gigas_text\n",
        "                    if \"ilimitado\" in plan_element.get_text().lower() or \"velocidad reducida\" in plan_element.get_text().lower():\n",
        "                        detalles_gigas = f\"{gigas} en Alta Velocidad (luego velocidad reducida)\"\n",
        "                    else:\n",
        "                        detalles_gigas = \"En Alta Velocidad\"\n",
        "                elif \"ilimitado\" in gigas_text.lower():\n",
        "                    gigas = \"Ilimitados\"\n",
        "                    detalles_gigas = \"Datos ilimitados (velocidad puede reducirse)\"\n",
        "                else:\n",
        "                    gigas = gigas_text\n",
        "                    detalles_gigas = \"N/A\"\n",
        "\n",
        "            is_max_ilimitado_promo = False\n",
        "            promo_div = plan_element.find('div', class_='cardPePromo')\n",
        "            if promo_div:\n",
        "                promo_text_span = promo_div.find('span', string=lambda text: text and 'Gigas, Minutos y SMS' in text)\n",
        "                if promo_text_span:\n",
        "                    is_max_ilimitado_promo = True\n",
        "                    minutos_llamadas = \"Ilimitadas\"\n",
        "                    sms = \"Ilimitados\"\n",
        "                    apps_ilimitadas = \"Incluidas en Todo Ilimitado\"\n",
        "\n",
        "            if not is_max_ilimitado_promo:\n",
        "                apps_list = []\n",
        "                app_icon_tags = plan_element.find_all('i', class_=lambda x: x and 'cIco-rs-' in x)\n",
        "                for icon_tag in app_icon_tags:\n",
        "                    for cls in icon_tag.get('class', []):\n",
        "                        if 'cIco-rs-' in cls:\n",
        "                            app_name = cls.replace('cIco-rs-', '')\n",
        "                            apps_list.append(app_name.capitalize())\n",
        "                apps_ilimitadas = \", \".join(apps_list) if apps_list else 'No especificado'\n",
        "                if apps_list:\n",
        "                    apps_ilimitadas = f\"{apps_ilimitadas} ilimitadas\"\n",
        "\n",
        "                if minutos_llamadas == 'No especificado':\n",
        "                    span_element_with_text = plan_element.find('span', string=lambda text: text and ('Llamadas y SMS' in text.strip() or 'Llamadas' in text.strip() or 'SMS' in text.strip()))\n",
        "                    if span_element_with_text:\n",
        "                        dt_parent = span_element_with_text.find_parent('dt')\n",
        "                        if dt_parent:\n",
        "                            dd_element = dt_parent.find_next_sibling('dd')\n",
        "                            if dd_element:\n",
        "                                calls_sms_text = dd_element.get_text(strip=True)\n",
        "                                if \"ilimitadas\" in calls_sms_text.lower():\n",
        "                                    minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                                    sms = \"SMS ilimitados\"\n",
        "                                else:\n",
        "                                    match_minutes = re.search(r'(\\d+)\\s*minutos', calls_sms_text, re.IGNORECASE)\n",
        "                                    if match_minutes:\n",
        "                                        minutos_llamadas = f\"{match_minutes.group(1)} minutos\"\n",
        "                                    else:\n",
        "                                        minutos_llamadas = calls_sms_text\n",
        "                                    match_sms = re.search(r'(\\d+)\\s*sms', calls_sms_text, re.IGNORECASE)\n",
        "                                    if match_sms:\n",
        "                                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "                                    else:\n",
        "                                        sms = calls_sms_text\n",
        "\n",
        "            plans_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratacion': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la extracción de Claro: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return plans_data\n",
        "\n",
        "def extraer_planes_bitel_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Bitel.\n",
        "    Este código usa Selenium y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes.\n",
        "    \"\"\"\n",
        "    url = \"https://bitel.com.pe/planes/control/ilimitado\"\n",
        "    planes_data = []\n",
        "\n",
        "    options = webdriver.ChromeOptions()\n",
        "    options.add_argument('--headless')\n",
        "    options.add_argument('--no-sandbox')\n",
        "    options.add_argument('--disable-dev-shm-usage')\n",
        "    options.add_argument('--window-size=1990,1080')\n",
        "    options.add_argument('--log-level=3')\n",
        "    options.add_experimental_option('excludeSwitches', ['enable-logging'])\n",
        "\n",
        "    driver = None\n",
        "    wait = None\n",
        "\n",
        "    try:\n",
        "        service = Service(ChromeDriverManager().install())\n",
        "        driver = webdriver.Chrome(service=service, options=options)\n",
        "        driver.get(url)\n",
        "\n",
        "        wait = WebDriverWait(driver, 45)\n",
        "\n",
        "        try:\n",
        "            common_close_xpaths = [\n",
        "                \"//button[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'Cerrar') or contains(., 'OK')]\",\n",
        "                \"//a[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'Cerrar') or contains(., 'OK')]\",\n",
        "                \"//div[contains(@class, 'close-button') or contains(@class, 'modal-close') or contains(@class, 'btn-close') or contains(@class, 'close-popup')]\",\n",
        "                \"//span[contains(text(), 'x') or contains(text(), 'X') or @class='close-icon']\",\n",
        "                \"//button[contains(@id, 'cookie') or contains(@id, 'modal') or contains(@class, 'cookie') or contains(@class, 'modal')][contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'OK')]\",\n",
        "                \"//div[@role='dialog']//button[contains(., 'Aceptar') or contains(., 'Entendido') or contains(., 'OK')]\"\n",
        "            ]\n",
        "\n",
        "            found_and_clicked = False\n",
        "            for xpath_str in common_close_xpaths:\n",
        "                try:\n",
        "                    btn = WebDriverWait(driver, 5).until(\n",
        "                        EC.element_to_be_clickable((By.XPATH, xpath_str))\n",
        "                    )\n",
        "                    if btn.is_displayed() and btn.is_enabled():\n",
        "                        btn.click()\n",
        "                        time.sleep(2)\n",
        "                        found_and_clicked = True\n",
        "                        break\n",
        "                except:\n",
        "                    pass\n",
        "\n",
        "        except Exception as e:\n",
        "            pass\n",
        "\n",
        "        try:\n",
        "            wait.until(EC.visibility_of_element_located((By.CLASS_NAME, 'cont-package')))\n",
        "        except Exception as e:\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight/2);\")\n",
        "            time.sleep(3)\n",
        "            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n",
        "            time.sleep(5)\n",
        "\n",
        "            try:\n",
        "                wait.until(EC.visibility_of_element_located((By.CLASS_NAME, 'cont-package')))\n",
        "            except Exception as e:\n",
        "                print(f\"ERROR FATAL: 'cont-package' no se hizo visible incluso después de scroll. {e}\")\n",
        "                print(\"La estructura de la página o la forma en que carga el contenido ha cambiado significativamente o hay un bloqueo persistente.\")\n",
        "                return []\n",
        "\n",
        "        time.sleep(5)\n",
        "\n",
        "        page_source = driver.page_source\n",
        "        soup = BeautifulSoup(page_source, 'html.parser')\n",
        "\n",
        "        plan_elements = soup.find_all('div', class_='cont-package')\n",
        "\n",
        "        if not plan_elements:\n",
        "            print(\"ERROR: Después de la carga, no se encontraron elementos con la clase 'cont-package' en BeautifulSoup.\")\n",
        "            print(\"Esto podría indicar que la clase ha cambiado o el contenido no está en el HTML parseado.\")\n",
        "            return []\n",
        "\n",
        "        for i, plan_element in enumerate(plan_elements):\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            detalles_gigas = 'N/A'\n",
        "\n",
        "            full_plan_text_raw = plan_element.get_text(separator=' ', strip=True)\n",
        "            full_plan_text_lower = full_plan_text_raw.lower()\n",
        "\n",
        "            match_precio = re.search(r's/\\s*(\\d+\\.\\d+)', full_plan_text_lower)\n",
        "            if match_precio:\n",
        "                precio = f\"S/ {match_precio.group(1)}\"\n",
        "            else:\n",
        "                price_element_a = plan_element.find('a', href=\"javascript:void(0);\")\n",
        "                if price_element_a:\n",
        "                    title_attr = price_element_a.get('title')\n",
        "                    if title_attr:\n",
        "                        match_price_title = re.search(r'(\\d+\\.\\d+)', title_attr)\n",
        "                        if match_price_title:\n",
        "                            precio = f\"S/ {match_price_title.group(1)}\"\n",
        "\n",
        "                if precio == 'N/A':\n",
        "                    match_precio_simple = re.search(r'(\\d+\\.\\d+)', full_plan_text_lower)\n",
        "                    if match_precio_simple:\n",
        "                        precio_val = float(match_precio_simple.group(1))\n",
        "                        if 10.00 <= precio_val <= 200.00:\n",
        "                            precio = f\"S/ {match_precio_simple.group(1)}\"\n",
        "\n",
        "            if precio != 'N/A':\n",
        "                nombre_plan = f\"Ilimitado - {precio.replace('S/ ', '')}\"\n",
        "            else:\n",
        "                name_span_element = plan_element.find('span', class_='color-white text-bold title-1g')\n",
        "                if name_span_element:\n",
        "                    span_text = name_span_element.get_text(strip=True)\n",
        "                    cleaned_span_text = re.sub(r'\\s*S/\\s*\\d+\\.\\d+', '', span_text, flags=re.IGNORECASE).strip()\n",
        "                    cleaned_span_text = re.sub(r'\\s*\\d+\\.\\d+$', '', cleaned_span_text, flags=re.IGNORECASE).strip()\n",
        "                    if cleaned_span_text:\n",
        "                        nombre_plan = f\"Ilimitado - {cleaned_span_text}\"\n",
        "                    else:\n",
        "                        nombre_plan = \"Ilimitado - Precio No Disponible\"\n",
        "                else:\n",
        "                    nombre_plan = \"Ilimitado - Precio No Disponible\"\n",
        "\n",
        "            gigas_element = plan_element.find('p', class_='capa')\n",
        "\n",
        "            if gigas_element:\n",
        "                gigas_text = gigas_element.get_text(strip=True)\n",
        "                gigas_text_lower = gigas_text.lower()\n",
        "\n",
        "                period_element = plan_element.find('p', class_='period')\n",
        "                period_text_lower = period_element.get_text(strip=True).lower() if period_element else ''\n",
        "\n",
        "                if 'ilimitados' in gigas_text_lower:\n",
        "                    gigas = 'Ilimitados'\n",
        "                    match_gigas_alta_velocidad = re.search(r'(\\d+)\\s*GB(?:\\s*en\\s*alta\\s*velocidad)?', gigas_text, re.IGNORECASE)\n",
        "                    if match_gigas_alta_velocidad:\n",
        "                        detalles_gigas = f\"{match_gigas_alta_velocidad.group(1)} GB en Alta Velocidad\"\n",
        "                    elif 'alta velocidad' in period_text_lower:\n",
        "                        detalles_gigas = \"Velocidad reducida después de cierto consumo\"\n",
        "                    else:\n",
        "                        detalles_gigas = \"Datos ilimitados sin restricciones de velocidad explícitas\"\n",
        "                else:\n",
        "                    match_gigas = re.search(r'(\\d+)\\s*GB', gigas_text, re.IGNORECASE)\n",
        "                    if match_gigas:\n",
        "                        gigas = f\"{match_gigas.group(1)} GB\"\n",
        "                        if 'alta velocidad' in period_text_lower:\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "                    else:\n",
        "                        gigas = gigas_text\n",
        "                        if 'alta velocidad' in period_text_lower:\n",
        "                            detalles_gigas = \"En Alta Velocidad\"\n",
        "            else:\n",
        "                gigas = 'N/A'\n",
        "                detalles_gigas = 'Elemento de gigas no encontrado'\n",
        "\n",
        "            app_keywords_patterns = {\n",
        "                'WhatsApp': r'whatsapp ilimitado',\n",
        "                'Facebook': r'facebook ilimitado',\n",
        "                'Instagram': r'instagram ilimitado',\n",
        "                'TikTok': r'tiktok ilimitado',\n",
        "                'Spotify': r'spotify ilimitado',\n",
        "                'Waze': r'waze ilimitado',\n",
        "                'YouTube': r'youtube ilimitado',\n",
        "                'Apps ilimitadas x meses': r'apps ilimitadas (x \\d+ meses)?',\n",
        "                'Internet + Llamadas ilimitadas': r'internet \\+\\s*llamadas ilimitadas'\n",
        "            }\n",
        "            found_apps = []\n",
        "            for app_name, pattern in app_keywords_patterns.items():\n",
        "                if re.search(pattern, full_plan_text_lower):\n",
        "                    if 'x \\d+ meses' in pattern and re.search(r'x \\d+ meses', full_plan_text_lower):\n",
        "                        promo_match = re.search(r'x \\d+ meses', full_plan_text_lower).group(0)\n",
        "                        found_apps.append(f\"{app_name.replace(' x meses', '')} {promo_match}\")\n",
        "                    else:\n",
        "                        found_apps.append(app_name)\n",
        "\n",
        "            app_image_elements = plan_element.find_all('li', class_='app-item')\n",
        "            for app_li in app_image_elements:\n",
        "                img_tag = app_li.find('img')\n",
        "                if img_tag and 'alt' in img_tag.attrs:\n",
        "                    app_name_from_alt = img_tag['alt'].strip()\n",
        "                    if app_name_from_alt and app_name_from_alt.lower() not in [app.lower() for app in found_apps]:\n",
        "                        found_apps.append(app_name_from_alt)\n",
        "\n",
        "            apps_ilimitadas = \", \".join(sorted(list(set(found_apps)))) if found_apps else 'No especificado'\n",
        "\n",
        "            minutos_llamadas = \"No especificado\"\n",
        "            sms = \"No especificado\"\n",
        "\n",
        "            todo_ilimitado_element = plan_element.find('p', class_=re.compile(r'title.*Todo ilimitado'))\n",
        "            if todo_ilimitado_element and \"todo ilimitado\" in todo_ilimitado_element.get_text(strip=True).lower():\n",
        "                minutos_llamadas = 'Llamadas ilimitadas'\n",
        "                sms = 'SMS ilimitados'\n",
        "            else:\n",
        "                if 'llamadas ilimitadas perú' in full_plan_text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas Perú'\n",
        "                    match_usa_canada = re.search(r'(\\d+)\\s*minutos\\s*(?:para|a)\\s*(?:usa|eeuu)\\s*(?:y|e)\\s*canadá', full_plan_text_lower)\n",
        "                    if match_usa_canada:\n",
        "                        minutos_llamadas += f\", {match_usa_canada.group(1)} minutos para Usa y Canadá\"\n",
        "                elif 'llamadas ilimitadas' in full_plan_text_lower:\n",
        "                    minutos_llamadas = 'Llamadas ilimitadas'\n",
        "\n",
        "                if 'sms ilimitados' in full_plan_text_lower:\n",
        "                    sms = 'SMS ilimitados'\n",
        "                else:\n",
        "                    match_sms = re.search(r'(\\d+)\\s*sms', full_plan_text_lower)\n",
        "                    if match_sms:\n",
        "                        sms = f\"{match_sms.group(1)} SMS\"\n",
        "\n",
        "            benefit_period_element = plan_element.find('p', class_='benefit-period')\n",
        "            if benefit_period_element and \"internet, llamadas y sms\" in benefit_period_element.get_text(strip=True).lower():\n",
        "                if minutos_llamadas == \"No especificado\":\n",
        "                    minutos_llamadas = 'Llamadas incluidas'\n",
        "                if sms == \"No especificado\":\n",
        "                    sms = 'SMS incluidos'\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratación': 'Postpago',\n",
        "                'Vigencia de Promoción': 'N/A'\n",
        "            })\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error crítico durante la ejecución: {e}\")\n",
        "        return []\n",
        "    finally:\n",
        "        if driver:\n",
        "            driver.quit()\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def extraer_planes_entel_colab():\n",
        "    \"\"\"\n",
        "    Función para extraer planes de Entel.\n",
        "    Este código usa requests y BeautifulSoup para el scraping.\n",
        "    Retorna una lista de diccionarios con los datos de los planes en formato estandarizado.\n",
        "    \"\"\"\n",
        "    url = \"https://ofertasentel.pe/?utm_source=bing&utm_medium=cpc_search&utm_campaign=pospago_promo_marcaplanes&utm_term=marca_planes&utmcampaign=0104020302&msclkid=dfab6aa18cde18a17c3b02cd920ff43b\"\n",
        "    planes_data = []\n",
        "\n",
        "    headers = {\n",
        "        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n",
        "    }\n",
        "\n",
        "    try:\n",
        "        response = requests.get(url, headers=headers, timeout=15)\n",
        "        response.raise_for_status()\n",
        "\n",
        "        soup = BeautifulSoup(response.content, 'html.parser')\n",
        "\n",
        "        plan_boxes = soup.find_all('div', class_='box')\n",
        "\n",
        "        if not plan_boxes:\n",
        "            print(\"ERROR (Entel): No se encontraron elementos con la clase 'box' en BeautifulSoup.\")\n",
        "            return []\n",
        "\n",
        "        for box in plan_boxes:\n",
        "            nombre_plan = 'N/A'\n",
        "            precio = 'N/A'\n",
        "            gigas = 'N/A'\n",
        "            detalles_gigas = 'N/A'\n",
        "            apps_ilimitadas = 'No especificado'\n",
        "            minutos_llamadas = 'No especificado'\n",
        "            sms = 'No especificado'\n",
        "            tipo_contratacion = 'Postpago'\n",
        "            vigencia_promocion = 'N/A'\n",
        "\n",
        "            plan_name_tag = box.find('div', class_='property property_internet')\n",
        "            if plan_name_tag and plan_name_tag.find('b'):\n",
        "                nombre_plan = plan_name_tag.find('b').get_text(strip=True)\n",
        "            elif box.find('h3'):\n",
        "                nombre_plan = box.find('h3').get_text(strip=True)\n",
        "\n",
        "            price_tag = box.find('div', class_='price')\n",
        "            if price_tag:\n",
        "                precio = price_tag.get_text(strip=True)\n",
        "\n",
        "            gb_div = box.find('div', class_='gb')\n",
        "            if gb_div:\n",
        "                strong_text = gb_div.find('strong').get_text(strip=True) if gb_div.find('strong') else ''\n",
        "                span_text = gb_div.find('span').get_text(strip=True) if gb_div.find('span') else ''\n",
        "\n",
        "                if 'ilimitado' in strong_text.lower():\n",
        "                    gigas = 'Ilimitados'\n",
        "                    if span_text:\n",
        "                        detalles_gigas = span_text.strip()\n",
        "                    else:\n",
        "                        detalles_gigas = \"Datos ilimitados sin restricciones de velocidad explícitas\"\n",
        "                else:\n",
        "                    gigas = strong_text.strip()\n",
        "                    if span_text:\n",
        "                        detalles_gigas = span_text.strip()\n",
        "                    else:\n",
        "                        detalles_gigas = \"N/A\"\n",
        "\n",
        "            app_tag = box.find('div', class_='property property_app')\n",
        "            if app_tag:\n",
        "                app_list_items = app_tag.find_all('li')\n",
        "                if app_list_items:\n",
        "                    apps_ilimitadas = \", \".join(sorted(list(set([li.get_text(strip=True) for li in app_list_items if li.get_text(strip=True)]))))\n",
        "                else:\n",
        "                    apps_ilimitadas = app_tag.get_text(strip=True, separator=' ')\n",
        "                if \"ilimitado\" not in apps_ilimitadas.lower() and \"ilimitadas\" not in apps_ilimitadas.lower() and apps_ilimitadas != 'N/A' and apps_ilimitadas != 'No especificado':\n",
        "                     apps_ilimitadas = f\"{apps_ilimitadas} ilimitadas\"\n",
        "\n",
        "            llamadas_tag = box.find('div', class_='property property_llamadas')\n",
        "            if llamadas_tag:\n",
        "                llamadas_text = llamadas_tag.get_text(strip=True)\n",
        "                if \"ilimitadas\" in llamadas_text.lower():\n",
        "                    minutos_llamadas = \"Llamadas ilimitadas\"\n",
        "                else:\n",
        "                    minutos_llamadas = llamadas_text\n",
        "\n",
        "            sms_tag = box.find('div', class_='property property_sms')\n",
        "            if sms_tag:\n",
        "                sms_text = sms_tag.get_text(strip=True)\n",
        "                if \"ilimitados\" in sms_text.lower():\n",
        "                    sms = \"SMS ilimitados\"\n",
        "                else:\n",
        "                    sms = sms_text\n",
        "\n",
        "            planes_data.append({\n",
        "                'Nombre del Plan': nombre_plan,\n",
        "                'Precio (S/)': precio,\n",
        "                'Gigas': gigas,\n",
        "                'Detalles de Gigas': detalles_gigas,\n",
        "                'Apps Ilimitadas': apps_ilimitadas,\n",
        "                'Minutos/Llamadas': minutos_llamadas,\n",
        "                'SMS': sms,\n",
        "                'Tipo de Contratacion': tipo_contratacion,\n",
        "                'Vigencia de Promoción': vigencia_promocion\n",
        "            })\n",
        "\n",
        "    except requests.exceptions.RequestException as e:\n",
        "        print(f\"Error de red al acceder a la página de Entel: {e}\")\n",
        "        return []\n",
        "    except Exception as e:\n",
        "        print(f\"Ocurrió un error inesperado durante el scraping de Entel: {e}\")\n",
        "        return []\n",
        "\n",
        "    return planes_data\n",
        "\n",
        "def standardize_plan_data(plan):\n",
        "    \"\"\"\n",
        "    Estandariza las claves y los tipos de datos de un diccionario de plan.\n",
        "    Asegura que 'Precio (S/)' sea un float.\n",
        "    \"\"\"\n",
        "    # Definir todas las claves esperadas y sus valores por defecto\n",
        "    standardized_plan = {\n",
        "        'Operador': plan.get('Operador', 'N/A'),\n",
        "        'Nombre del Plan': plan.get('Nombre del Plan', 'N/A'),\n",
        "        'Precio (S/)': plan.get('Precio (S/)', 'N/A'),\n",
        "        'Gigas': plan.get('Gigas', 'N/A'),\n",
        "        'Detalles de Gigas': plan.get('Detalles de Gigas', 'N/A'),\n",
        "        'Apps Ilimitadas': plan.get('Apps Ilimitadas', 'No especificado'),\n",
        "        'Minutos/Llamadas': plan.get('Minutos/Llamadas', 'No especificado'),\n",
        "        'SMS': plan.get('SMS', 'No especificado'),\n",
        "        'Tipo de Contratación': plan.get('Tipo de Contratación', 'Postpago'),\n",
        "        'Vigencia de Promoción': plan.get('Vigencia de Promoción', 'N/A')\n",
        "    }\n",
        "\n",
        "    # Convertir Precio (S/) a float\n",
        "    precio_raw = standardized_plan['Precio (S/)']\n",
        "    if isinstance(precio_raw, str):\n",
        "        precio_str = precio_raw.replace('S/', '').replace(',', '.').strip()\n",
        "        try:\n",
        "            standardized_plan['Precio (S/)'] = float(precio_str)\n",
        "        except ValueError:\n",
        "            standardized_plan['Precio (S/)'] = None # Usar None si no se puede convertir a número\n",
        "    elif not isinstance(precio_raw, (int, float)):\n",
        "        standardized_plan['Precio (S/)'] = None # Asegurarse de que sea None si no es número ni string convertible\n",
        "\n",
        "    return standardized_plan\n",
        "\n",
        "def get_all_telecom_plans():\n",
        "    \"\"\"\n",
        "    Extrae y combina los planes de todos los operadores.\n",
        "    Retorna un DataFrame de Pandas con los datos estandarizados.\n",
        "    \"\"\"\n",
        "    all_plans = []\n",
        "\n",
        "    # --- Extraer y combinar planes de Movistar ---\n",
        "    try:\n",
        "        movistar_plans = extraer_planes_movistar_colab()\n",
        "        for plan in movistar_plans:\n",
        "            plan['Operador'] = 'Movistar'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Movistar: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Claro ---\n",
        "    try:\n",
        "        claro_plans = extraer_planes_claro_colab()\n",
        "        for plan in claro_plans:\n",
        "            plan['Operador'] = 'Claro'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Claro: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Bitel ---\n",
        "    try:\n",
        "        bitel_plans = extraer_planes_bitel_colab()\n",
        "        for plan in bitel_plans:\n",
        "            plan['Operador'] = 'Bitel'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Bitel: {e}\")\n",
        "\n",
        "    # --- Extraer y combinar planes de Entel ---\n",
        "    try:\n",
        "        entel_plans = extraer_planes_entel_colab()\n",
        "        for plan in entel_plans:\n",
        "            plan['Operador'] = 'Entel'\n",
        "            all_plans.append(standardize_plan_data(plan))\n",
        "    except Exception as e:\n",
        "        print(f\"Error al extraer planes de Entel: {e}\")\n",
        "\n",
        "    df = pd.DataFrame(all_plans)\n",
        "\n",
        "    # Ordenar por precio, asegurando que los valores 'N/A' o None vayan al final\n",
        "    df['Precio_Sort'] = df['Precio (S/)'].apply(lambda x: x if isinstance(x, (int, float)) else float('inf'))\n",
        "    df_sorted = df.sort_values(by='Precio_Sort').drop(columns='Precio_Sort')\n",
        "\n",
        "    return df_sorted\n",
        "\n",
        "# --- Inicializar la aplicación Dash ---\n",
        "app = dash.Dash(__name__)\n",
        "\n",
        "# Cargar los datos iniciales\n",
        "df_plans = get_all_telecom_plans()\n",
        "\n",
        "# Obtener opciones únicas de operadores para el dropdown\n",
        "operator_options = [{'label': 'Todos', 'value': 'all'}] + \\\n",
        "                   [{'label': op, 'value': op} for op in df_plans['Operador'].unique()]\n",
        "\n",
        "# --- Diseño de la aplicación Dash ---\n",
        "app.layout = html.Div(style={'fontFamily': 'Arial, sans-serif', 'padding': '20px', 'backgroundColor': '#f4f4f4', 'color': '#333'}, children=[\n",
        "    html.H1(\"Comparador de Planes Telefónicos\", style={'textAlign': 'center', 'color': '#007bff'}),\n",
        "\n",
        "    html.Div([\n",
        "        html.Label(\"Filtrar por Operador:\", style={'marginRight': '10px', 'fontWeight': 'bold'}),\n",
        "        dcc.Dropdown(\n",
        "            id='operator-dropdown',\n",
        "            options=operator_options,\n",
        "            value='all',\n",
        "            clearable=False,\n",
        "            style={'width': '200px', 'display': 'inline-block', 'verticalAlign': 'middle'}\n",
        "        ),\n",
        "    ], style={'marginBottom': '20px', 'textAlign': 'center'}),\n",
        "\n",
        "    dash_table.DataTable(\n",
        "        id='plans-table',\n",
        "        columns=[{\"name\": i, \"id\": i} for i in df_plans.columns],\n",
        "        data=df_plans.to_dict('records'),\n",
        "        style_table={'overflowX': 'auto', 'boxShadow': '0 4px 12px rgba(0,0,0,0.15)', 'borderRadius': '8px'},\n",
        "        style_header={\n",
        "            'backgroundColor': '#00AEEF',\n",
        "            'color': 'white',\n",
        "            'fontWeight': 'bold',\n",
        "            'textAlign': 'left',\n",
        "            'padding': '15px 20px',\n",
        "            'textTransform': 'uppercase',\n",
        "            'fontSize': '0.95em',\n",
        "            'letterSpacing': '0.5px'\n",
        "        },\n",
        "        style_data={\n",
        "            'backgroundColor': 'white',\n",
        "            'color': '#333',\n",
        "            'borderBottom': '1px solid #eee',\n",
        "            'padding': '15px 20px'\n",
        "        },\n",
        "        style_data_conditional=[\n",
        "            {\n",
        "                'if': {'row_index': 'even'},\n",
        "                'backgroundColor': '#f8f8f8'\n",
        "            },\n",
        "            {\n",
        "                'if': {'state': 'active'},\n",
        "                'backgroundColor': '#e0f7fa',\n",
        "                'border': '1px solid #00AEEF'\n",
        "            }\n",
        "        ],\n",
        "        filter_action=\"native\",\n",
        "        sort_action=\"native\",\n",
        "        page_action=\"native\",\n",
        "        page_size=10,\n",
        "    )\n",
        "])\n",
        "\n",
        "# --- Callbacks para interactividad ---\n",
        "@app.callback(\n",
        "    Output('plans-table', 'data'),\n",
        "    Input('operator-dropdown', 'value')\n",
        ")\n",
        "def update_table(selected_operator):\n",
        "    if selected_operator == 'all':\n",
        "        return df_plans.to_dict('records')\n",
        "    else:\n",
        "        filtered_df = df_plans[df_plans['Operador'] == selected_operator]\n",
        "        return filtered_df.to_dict('records')\n",
        "\n",
        "# --- Ejecutar la aplicación Dash en Colab ---\n",
        "if __name__ == '__main__':\n",
        "    app.run(mode='inline', port=8050)\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "-ObM1lQeQny4",
        "outputId": "43319fb3-f594-4c3d-baee-90f4846e1928"
      },
      "execution_count": 2,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "gpg: cannot open '/dev/tty': No such device or address\n",
            "deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome-archive-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main\n",
            "Hit:1 http://dl.google.com/linux/chrome/deb stable InRelease\n",
            "Hit:2 https://cloud.r-project.org/bin/linux/ubuntu jammy-cran40/ InRelease\n",
            "Hit:3 https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64  InRelease\n",
            "Hit:4 http://security.ubuntu.com/ubuntu jammy-security InRelease\n",
            "Hit:5 https://r2u.stat.illinois.edu/ubuntu jammy InRelease\n",
            "Hit:6 http://archive.ubuntu.com/ubuntu jammy InRelease\n",
            "Get:7 http://archive.ubuntu.com/ubuntu jammy-updates InRelease [128 kB]\n",
            "Hit:8 https://ppa.launchpadcontent.net/deadsnakes/ppa/ubuntu jammy InRelease\n",
            "Hit:9 https://ppa.launchpadcontent.net/graphics-drivers/ppa/ubuntu jammy InRelease\n",
            "Hit:10 https://ppa.launchpadcontent.net/ubuntugis/ppa/ubuntu jammy InRelease\n",
            "Hit:11 http://archive.ubuntu.com/ubuntu jammy-backports InRelease\n",
            "Fetched 128 kB in 1s (97.0 kB/s)\n",
            "Reading package lists... Done\n",
            "W: Skipping acquire of configured file 'main/source/Sources' as repository 'https://r2u.stat.illinois.edu/ubuntu jammy InRelease' does not seem to provide it (sources.list entry misspelt?)\n",
            "Reading package lists... Done\n",
            "Building dependency tree... Done\n",
            "Reading state information... Done\n",
            "google-chrome-stable is already the newest version (138.0.7204.100-1).\n",
            "0 upgraded, 0 newly installed, 0 to remove and 39 not upgraded.\n",
            "Google Chrome 138.0.7204.100 \n",
            "\n",
            "--- Instalación de Chrome y dependencias completada ---\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<IPython.core.display.Javascript object>"
            ],
            "application/javascript": [
              "(async (port, path, width, height, cache, element) => {\n",
              "    if (!google.colab.kernel.accessAllowed && !cache) {\n",
              "      return;\n",
              "    }\n",
              "    element.appendChild(document.createTextNode(''));\n",
              "    const url = await google.colab.kernel.proxyPort(port, {cache});\n",
              "    const iframe = document.createElement('iframe');\n",
              "    iframe.src = new URL(path, url).toString();\n",
              "    iframe.height = height;\n",
              "    iframe.width = width;\n",
              "    iframe.style.border = 0;\n",
              "    iframe.allow = [\n",
              "        'accelerometer',\n",
              "        'autoplay',\n",
              "        'camera',\n",
              "        'clipboard-read',\n",
              "        'clipboard-write',\n",
              "        'gyroscope',\n",
              "        'magnetometer',\n",
              "        'microphone',\n",
              "        'serial',\n",
              "        'usb',\n",
              "        'xr-spatial-tracking',\n",
              "    ].join('; ');\n",
              "    element.appendChild(iframe);\n",
              "  })(8050, \"/\", \"100%\", 650, false, window.element)"
            ]
          },
          "metadata": {}
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
